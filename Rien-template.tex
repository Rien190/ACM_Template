\documentclass[a4paper,11pt]{article}
\usepackage{zh_CN-Adobefonts_external} % Simplified Chinese Support using external fonts (./fonts/zh_CN-Adobe/)
\usepackage{fancyhdr}  % 页眉页脚
\usepackage{minted}    % 代码高亮
\usepackage[colorlinks]{hyperref}  % 目录可跳转
\usepackage{graphicx}
\setlength{\headheight}{15pt}

\hypersetup {
    colorlinks=true,
    linkcolor=black
}
\renewcommand\theFancyVerbLine{\large\arabic{FancyVerbLine}}

% 定义页眉页脚
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{ACM Template by Rien}
\lfoot{}
\cfoot{\thepage}
\rfoot{}

\author{Rien}
\title{ACM Template}

\begin{document}
\maketitle % 封面

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth,]{picture/logo.jpg}
    \vspace{0.5cm}
\end{figure}
\centerline{rien\_zhu@163.com}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage % 换页
\tableofcontents % 目录
%\twocolumn  % 分页显示
\newpage
\section{字符串}
\subsection{KMP}
\inputminted[breaklines,linenos,frame=leftline]{c++}{string/kmp.cc}

\subsection{Suffix Automaton}
\inputminted[breaklines]{c++}{string/suffix-automaton.cc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{数据结构}
\subsection{01字典树}
\inputminted[breaklines]{c++}{DataStruct/trie.cpp}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{数学}

\subsection{快速幂}
\subsubsection{数字快速幂}
\inputminted[breaklines,linenos,frame=leftline]{c++}{math/quickpow1.cpp}

\subsection{莫比乌斯反演}
\subsubsection{整除分块}
可以用到整除分块的形式，大致是这样的：
$$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor $$
用整除分块可以在$O  (\sqrt{n})$求出,代码如下:
\inputminted[breaklines,linenos,frame=leftline]{c++}{math/RemoveTheBlock.cpp}
\subsubsection{莫比乌斯函数}
\inputminted[breaklines,linenos,frame=leftline]{c++}{math/MobiusFunction.cpp}

\subsection{BSGS}
\inputminted[breaklines,linenos,frame=leftline]{c++}{math/BSGS.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{图论} % 一级标题
\subsection{最小生成树} % 二级标题
无向图中，其某个子图中任意两个顶点都互相连通并且是一棵树，称之为生成树；若每个顶点有权值，则其权值和最小的生成树为最小生成树。
\subsubsection{Prim算法}
\inputminted[breaklines,linenos,frame=leftline]{c++}{graph/prim.cpp}
\subsubsection{Kruskal算法} % 三级标题
\inputminted[breaklines,linenos,frame=leftline]{c++}{graph/kruskal.cpp}
% 中文测试
\subsection{单源最短路}
\subsubsection{SPFA}
\inputminted[breaklines]{c++}{graph/spfa.cc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{动态规划}
\subsection{悬线法}
\paragraph{}
悬线法的用途：针对求给定矩阵中满足某条件的极大矩阵，比如“面积最大的长方形、正方形”“周长最长的矩形等等”。

悬线法的基本思路：维护三个二维数组，Left,Right,Up数组。

Left数组存储从map[i][j]这个点出发，满足条件能到达的最左边地方。

Right数组存储从map[i][j]这个点出发，满足条件能到达的最右边地方。

Up数组存储从这点以上满足条件的能到达的最大长度。

递推公式：

Up：Up[i][j] = Up[i-1][j] + 1

Right：min(Right[i][j]，Right[i-1],[j])

Left:：max(Left[i][j]，Left[i-1][j])
\inputminted[breaklines,linenos,frame=leftline]{c++}{DP/StretchedWire.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{其他}
\subsection{输入输出}
\subsubsection{快读}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/read1.cpp}
\subsubsection{关闭同步}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/read2.cpp}
\subsubsection{快读快写}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/read3.cpp}
\subsubsection{7.19所用板子}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/7.19.cpp}
\subsection{高精度}
\subsubsection{简单高精度}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/bignum2.cpp}
\subsubsection{压位高精度}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/bignum1.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{注意事项}
\begin{itemize}
    \item 注意范围!!!爆int多少回了?有时候ans定义为ll也是不够的,注意改为ll后scanf和printf,不行就signed main,\#define int ll
    \item 注意初始点的设置,初始点是否有效是否得到正确的更新
    \item 注意边界条件如$<$和$<=$,注意特判如$n=1$
\end{itemize}




\end{document}
