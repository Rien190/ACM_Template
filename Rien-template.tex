\documentclass[a4paper,11pt]{article}
\usepackage{zh_CN-Adobefonts_external} % Simplified Chinese Support using external fonts (./fonts/zh_CN-Adobe/)
\usepackage{fancyhdr}  % 页眉页脚
\usepackage{minted}    % 代码高亮
\usepackage[colorlinks]{hyperref}  % 目录可跳转
\usepackage{graphicx}
\usepackage{amsmath}
\setlength{\headheight}{15pt}

\hypersetup {
    colorlinks=true,
    linkcolor=black
}
\renewcommand\theFancyVerbLine{\large\arabic{FancyVerbLine}}

% 定义页眉页脚
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{ACM Template by Rien}
\lfoot{}
\cfoot{\thepage}
\rfoot{}

\author{Rien}
\title{ACM Template}

\begin{document}
\maketitle % 封面
\thispagestyle{empty}%目录页不显示页码

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth,]{picture/logo.jpg}
    \vspace{0.5cm}
\end{figure}
\centerline{rien\_zhu@163.com}
\newpage % 换页
\tableofcontents % 目录
\thispagestyle{empty}%目录页不显示页码
%\twocolumn  % 分页显示
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\setcounter{page}{1}%从下面开始编页码
\section{字符串}
\subsection{KMP}
\inputminted[breaklines,linenos,frame=leftline]{c++}{string/kmp.cpp}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{数据结构}

\subsection{并查集}
\subsubsection{优化并查集}
\inputminted[breaklines,linenos,frame=leftline]{c++}{DataStruct/disjoint1.cpp}

\subsection{01字典树}
\inputminted[breaklines,linenos,frame=leftline]{c++}{DataStruct/trie.cpp}

\subsection{树状数组}
\subsubsection{一维树状数组}
\inputminted[breaklines,linenos,frame=leftline]{c++}{DataStruct/BIT1.cpp}
\subsubsection{求逆序对}
\inputminted[breaklines,linenos,frame=leftline]{c++}{DataStruct/BIT2.cpp}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{数学}

\subsection{快速幂}
\subsubsection{数字快速幂}
\inputminted[breaklines,linenos,frame=leftline]{c++}{math/quickpow1.cpp}

\subsection{组合数学}
\inputminted[breaklines,linenos,frame=leftline]{c++}{math/com.cpp}

\subsection{莫比乌斯反演}
\subsubsection{整除分块}
可以用到整除分块的形式，大致是这样的：
$$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor $$
用整除分块可以在$O  (\sqrt{n})$求出,代码如下:
\inputminted[breaklines,linenos,frame=leftline]{c++}{math/RemoveTheBlock.cpp}
\subsubsection{莫比乌斯函数}
\inputminted[breaklines,linenos,frame=leftline]{c++}{math/MobiusFunction.cpp}

\subsection{BSGS}
\inputminted[breaklines,linenos,frame=leftline]{c++}{math/BSGS.cpp}

\subsection{中国剩余定理}
中国剩余定理 (Chinese Remainder Theorem, CRT) 可求解如下形式的一元线性同余方程组（其中 $n_1, n_2, \cdots, n_k$ 两两互质）：
$$
\begin{cases}
x &\equiv a_1 \pmod {n_1} \\
x &\equiv a_2 \pmod {n_2} \\
  &\vdots \\
x &\equiv a_k \pmod {n_k} \\
\end{cases}
$$
算法流程
\begin{enumerate}
    \item 计算所有模数的积 $n$；
    \item 对于第 $i$ 个方程：
        \begin{enumerate}
            \item 计算 $m_i=\frac{n}{n_i}$；
            \item 计算 $m_i$ 在模 $n_i$ 意义下的 [逆元](./inverse.md)  $m_i^{-1}$；
            \item 计算 $c_i=m_im_i^{-1}$（不要对 $n_i$ 取模）。
        \end{enumerate}
    \item 方程组的唯一解为：$x=\sum_{i=1}^k a_ic_i \pmod n$。
\end{enumerate}
代码如下:
\inputminted[breaklines,linenos,frame=leftline]{c++}{math/crt.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{图论} % 一级标题

\subsection{BFS}
\subsubsection{伪代码}
\inputminted[breaklines,linenos,frame=leftline]{c++}{graph/bfs1.cpp}
\subsubsection{BFS记录距离和路径}
\inputminted[breaklines,linenos,frame=leftline]{c++}{graph/bfs2.cpp}

\subsection{最短路}
\subsubsection{Dijkstra算法单源最短路}
\inputminted[breaklines,linenos,frame=leftline]{c++}{graph/shortest1.cpp}
\subsubsection{bellman\_ford算法单源最短路}
\inputminted[breaklines,linenos,frame=leftline]{c++}{graph/shortest2.cpp}
\subsubsection{Floyd任意两点最短路径}
\inputminted[breaklines,linenos,frame=leftline]{c++}{graph/shortest3.cpp}

\subsection{最小生成树} % 二级标题
无向图中，其某个子图中任意两个顶点都互相连通并且是一棵树，称之为生成树；若每个顶点有权值，则其权值和最小的生成树为最小生成树。
\subsubsection{Prim算法}
\inputminted[breaklines,linenos,frame=leftline]{c++}{graph/prim.cpp}
\subsubsection{Kruskal算法} % 三级标题
\inputminted[breaklines,linenos,frame=leftline]{c++}{graph/kruskal.cpp}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{动态规划}
\subsection{悬线法}
\paragraph{}
悬线法的用途：针对求给定矩阵中满足某条件的极大矩阵，比如“面积最大的长方形、正方形”“周长最长的矩形等等”。

悬线法的基本思路：维护三个二维数组，Left,Right,Up数组。

Left数组存储从map[i][j]这个点出发，满足条件能到达的最左边地方。

Right数组存储从map[i][j]这个点出发，满足条件能到达的最右边地方。

Up数组存储从这点以上满足条件的能到达的最大长度。

递推公式：

Up：Up[i][j] = Up[i-1][j] + 1

Right：min(Right[i][j]，Right[i-1],[j])

Left:：max(Left[i][j]，Left[i-1][j])
\inputminted[breaklines,linenos,frame=leftline]{c++}{DP/StretchedWire.cpp}

\subsection{LIS 最长上升子序列}
\inputminted[breaklines,linenos,frame=leftline]{c++}{DP/lis.cpp}

\subsection{背包}
\subsubsection{基础背包}
\inputminted[breaklines,linenos,frame=leftline]{c++}{DP/pack.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{杂项}

\subsection{输入输出}
\subsubsection{快读}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/read1.cpp}
\subsubsection{关闭同步}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/read2.cpp}
\subsubsection{快读快写}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/read3.cpp}
\subsubsection{8.11所用板子}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/7.19.cpp}

\subsection{高精度}
\subsubsection{int128}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/int128.cpp}
\subsubsection{简单高精度}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/bignum2.cpp}
\subsubsection{压位高精度}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/bignum1.cpp}

\subsection{离散化}
\inputminted[breaklines,linenos,frame=leftline]{c++}{others/discretize.cpp}

\subsection{常用公式}
\begin{itemize}
    \item $\sum_{i=1}^{n} i = \frac{n*(n+1)}{2} $
    \item $\sum_{i=1}^{n} i^2 = \frac{n*(n+1)*(2n+1)}{6} $
    \item $\sum_{i=1}^{n} i^3 = \left[\frac{n*(n+1)}{2}\right]^2 $
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{经典例题}
\subsection{某天是星期几}
\inputminted[breaklines]{c++}{question/1.cpp}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{注意事项}
\begin{itemize}
    \item 注意范围!!!爆int多少回了?有时候ans定义为ll也是不够的,注意改为ll后scanf和printf,不行就signed main,\#define int ll
    \item 注意初始点的设置,初始点是否有效是否得到正确的更新
    \item 注意边界条件如$<$和$<=$,注意特判如$n=1$
\end{itemize}




\end{document}
